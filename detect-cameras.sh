#!/usr/bin/env bash
# detect-cameras.sh
# Lists all V4L2 video devices visible to FFmpeg,
# then writes cameras.conf pre-filled with ALL detected cameras.
#
# Requires: ffmpeg, v4l-utils  (sudo apt install ffmpeg v4l-utils)

set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONF_FILE="$SCRIPT_DIR/cameras.conf"

# ---------------------------------------------------------------------------
# Check dependencies
# ---------------------------------------------------------------------------

for cmd in ffmpeg v4l2-ctl; do
    if ! command -v "$cmd" &>/dev/null; then
        echo "ERROR: '$cmd' is not installed."
        echo "Install with:  sudo apt install ffmpeg v4l-utils"
        exit 1
    fi
done

# ---------------------------------------------------------------------------
# Discover V4L2 devices
# ---------------------------------------------------------------------------

echo "Scanning V4L2 video devices..."
echo ""

# Build a list of [device_path, friendly_name] pairs.
# v4l2-ctl --list-devices output looks like:
#   HP 5MP Camera (usb-0000:00:01.2-1):
#           /dev/video0
#           /dev/video1
#
# We keep only the first /dev/videoN per camera (the main capture node),
# skipping metadata nodes (/dev/video1 for the same camera hub, etc.).

declare -a DEVICES=()      # /dev/videoN paths
declare -a NAMES=()        # friendly names

current_name=""
while IFS= read -r line; do
    # Lines with a colon at the end are device name headers
    if [[ "$line" =~ ^([^/].+)\(.*\):$ ]]; then
        # Strip trailing whitespace from name
        current_name=$(echo "${BASH_REMATCH[1]}" | sed 's/[[:space:]]*$//')
    elif [[ "$line" =~ ^[[:space:]]+(/dev/video[0-9]+)$ ]]; then
        dev="${BASH_REMATCH[1]}"
        # Only take the first node for each camera name
        already_added=0
        for n in "${NAMES[@]:-}"; do
            [[ "$n" == "$current_name" ]] && already_added=1 && break
        done
        if [[ $already_added -eq 0 && -n "$current_name" ]]; then
            # Verify FFmpeg can open this node as a video capture device
            if v4l2-ctl -d "$dev" --get-fmt-video &>/dev/null 2>&1; then
                DEVICES+=("$dev")
                NAMES+=("$current_name")
            fi
        fi
    fi
done < <(v4l2-ctl --list-devices 2>/dev/null)

if [[ ${#DEVICES[@]} -eq 0 ]]; then
    echo "WARNING: No V4L2 video devices found."
    echo ""
    echo "Troubleshooting tips:"
    echo "  - Make sure cameras are plugged in (check: ls /dev/video*)"
    echo "  - Check dmesg for USB errors:  dmesg | grep -i usb | tail -20"
    echo "  - If running in a VM, verify USB passthrough is configured in Proxmox"
    exit 1
fi

echo "Found ${#DEVICES[@]} video device(s):"
for i in "${!DEVICES[@]}"; do
    echo "  [$((i+1))]  ${DEVICES[$i]}  â€”  ${NAMES[$i]}"
done
echo ""

# ---------------------------------------------------------------------------
# Write cameras.conf
# ---------------------------------------------------------------------------

{
    echo "# cameras.conf - Generated by detect-cameras.sh"
    echo "# Edit the values below if needed, then run start-streams.sh"
    echo "# Add or remove CAMERA blocks to include/exclude cameras."
    echo "# CAMERA<n>_DEVICE : the V4L2 device path (e.g. /dev/video0)"
    echo "# CAMERA<n>_STREAM : the RTSP path  rtsp://<host>:8554/<stream>"
    echo ""

    for i in "${!DEVICES[@]}"; do
        n=$((i+1))
        echo "# --- Camera $n ---"
        echo "# Device found: ${NAMES[$i]}"
        echo "CAMERA${n}_DEVICE=${DEVICES[$i]}"
        echo "CAMERA${n}_STREAM=cam${n}"
        echo ""
    done

    cat <<'EOF'
# --- Encoding Settings (applied to all cameras) ---
# Target average bitrate in kbps per stream.
# 8000 = ~8 Mbit/s (high quality 1080p).  Raise to 12000-20000 for 4K.
BITRATE=8000

# Maximum bitrate cap (kbps) - typically 1.5-2x BITRATE to absorb peaks
MAXRATE=12000

# Force a specific resolution, e.g. 1920x1080  (leave blank = camera native)
RESOLUTION=

# Force a specific framerate, e.g. 30  (leave blank = camera native)
FRAMERATE=

# H.264 CRF quality: 0=lossless, 18=visually lossless, 23=default, 28=fast
# Lower = better quality AND larger file/stream size.
# 18 is the recommended sweet-spot for best quality.
CRF=18

# x264 preset: ultrafast / superfast / veryfast / faster / fast / medium
# Slower preset = better compression at same quality, but more CPU usage.
# veryfast is a solid balance for real-time capture.
PRESET=veryfast
EOF
} > "$CONF_FILE"

echo "cameras.conf written to $CONF_FILE  (${#DEVICES[@]} camera(s) configured)"
echo ""
echo "Review the file, then run  ./start-streams.sh  to start broadcasting."
echo ""
