# start-streams.ps1
# Reads cameras.conf, starts MediaMTX, then launches one FFmpeg process per camera.
# Supports any number of cameras defined in cameras.conf.
# Keep this window open while streaming. Press Ctrl+C to stop everything cleanly.

$ErrorActionPreference = "Stop"
$scriptDir    = $PSScriptRoot
$ffmpeg       = "$scriptDir\tools\ffmpeg\bin\ffmpeg.exe"
$mediamtxExe  = "$scriptDir\tools\mediamtx\mediamtx.exe"
# Store mediamtx.yml next to the exe so the path is free of spaces/special chars
$mediamtxYml  = "$scriptDir\tools\mediamtx\mediamtx.yml"
$confFile     = "$scriptDir\cameras.conf"

# ---------------------------------------------------------------------------
# Pre-flight checks
# ---------------------------------------------------------------------------

foreach ($f in @($ffmpeg, $mediamtxExe, $confFile)) {
    if (-not (Test-Path $f)) {
        Write-Host ""
        Write-Host "ERROR: Missing required file:" -ForegroundColor Red
        Write-Host "  $f" -ForegroundColor Red
        Write-Host "Make sure you have run setup.ps1 and detect-cameras.ps1 first." -ForegroundColor Yellow
        Write-Host ""
        Write-Host "Press Enter to close..."
        Read-Host | Out-Null
        exit 1
    }
}

# ---------------------------------------------------------------------------
# Parse cameras.conf
# ---------------------------------------------------------------------------

$conf = @{}
Get-Content $confFile |
    Where-Object { $_ -notmatch '^\s*#' -and $_ -match '^\s*\w+\s*=' } |
    ForEach-Object {
        $parts = $_ -split '=', 2
        $conf[$parts[0].Trim()] = $parts[1].Trim()
    }

function Conf($key, $default = '') {
    if ($conf.ContainsKey($key) -and $conf[$key] -ne '') { return $conf[$key] }
    return $default
}

$bitrate    = Conf "BITRATE"   "8000"
$maxrate    = Conf "MAXRATE"   "12000"
$crf        = Conf "CRF"       "18"
$preset     = Conf "PRESET"    "veryfast"
$resolution = Conf "RESOLUTION"
$framerate  = Conf "FRAMERATE"

# Discover all CAMERA<n>_NAME keys dynamically (supports any number of cameras)
$cameras = [System.Collections.Generic.List[hashtable]]::new()
$index = 1
while ($true) {
    $name   = Conf "CAMERA${index}_NAME"
    $stream = Conf "CAMERA${index}_STREAM" "cam$index"
    if (-not $name) { break }
    $cameras.Add(@{ Index = $index; Name = $name; Stream = $stream })
    $index++
}

if ($cameras.Count -eq 0) {
    Write-Host ""
    Write-Host "ERROR: No CAMERA1_NAME found in cameras.conf." -ForegroundColor Red
    Write-Host "Run detect-cameras.ps1 first." -ForegroundColor Yellow
    Write-Host ""
    Write-Host "Press Enter to close..."
    Read-Host | Out-Null
    exit 1
}

Write-Host "[Config] Found $($cameras.Count) camera(s) in cameras.conf."

# ---------------------------------------------------------------------------
# Write mediamtx.yml
# ---------------------------------------------------------------------------

# Build mediamtx.yml dynamically with one path block per camera
$ymlLines = [System.Collections.Generic.List[string]]::new()
$ymlLines.Add("# mediamtx.yml - auto-generated by start-streams.ps1")
$ymlLines.Add("")
$ymlLines.Add("logLevel: info")
$ymlLines.Add("logDestinations: [stdout]")
$ymlLines.Add("")
$ymlLines.Add("rtsp: yes")
$ymlLines.Add("rtspAddress: :8554")
$ymlLines.Add('rtspEncryption: "no"')
$ymlLines.Add("")
$ymlLines.Add("rtmp: no")
$ymlLines.Add("hls: no")
$ymlLines.Add("webrtc: no")
$ymlLines.Add("srt: no")
$ymlLines.Add("")
$ymlLines.Add("paths:")
foreach ($cam in $cameras) {
    $ymlLines.Add("  $($cam.Stream):")
    $ymlLines.Add("    source: publisher")
}

$ymlLines | Set-Content $mediamtxYml -Encoding UTF8
Write-Host "[Config] mediamtx.yml written ($($cameras.Count) path(s))."

# ---------------------------------------------------------------------------
# Build FFmpeg argument lists
# ---------------------------------------------------------------------------

function Build-FFmpegArgs {
    param (
        [string]$CameraName,
        [string]$StreamPath
    )

    $args = [System.Collections.Generic.List[string]]@(
        "-f", "dshow",
        "-rtbufsize", "256M"   # large ring buffer to avoid dropped frames
    )

    # Optional overrides
    if ($resolution) { $args.AddRange([string[]]@("-video_size", $resolution)) }
    if ($framerate)  { $args.AddRange([string[]]@("-framerate",  $framerate))  }

    $args.AddRange([string[]]@(
        "-i", "`"video=$CameraName`"",

        # H.264 encoding - visually lossless quality
        "-c:v", "libx264",
        "-preset", $preset,
        "-tune", "zerolatency",     # minimise latency (important for live monitoring)
        "-crf", $crf,               # quality target (18 = visually lossless)
        "-maxrate", "${maxrate}k",  # bitrate cap for network headroom
        "-bufsize", "$([int]$maxrate * 2)k",
        "-pix_fmt", "yuv420p",      # broadest decoder compatibility
        "-an",                          # no audio - avoids dshow audio device errors

        # RTSP output to MediaMTX
        "-f", "rtsp",
        "-rtsp_transport", "tcp",
        "rtsp://localhost:8554/$StreamPath"
    ))

    return $args.ToArray()
}

# ---------------------------------------------------------------------------
# Start MediaMTX
# ---------------------------------------------------------------------------

# mediamtx.yml lives in the same folder as the exe.
# Launch MediaMTX with that folder as working directory and no path argument
# so it auto-discovers mediamtx.yml - this avoids passing a path with
# spaces or special characters (å, ø, etc.) on the command line.
$mediamtxDir  = Split-Path $mediamtxExe -Parent
$mediamtxLog  = "$mediamtxDir\mediamtx.log"

Write-Host "[MediaMTX] Starting RTSP server..."
$mediamtxProc = Start-Process `
    -FilePath $mediamtxExe `
    -WorkingDirectory $mediamtxDir `
    -RedirectStandardOutput $mediamtxLog `
    -RedirectStandardError  "$mediamtxDir\mediamtx-err.log" `
    -PassThru `
    -NoNewWindow

Start-Sleep -Seconds 2

if ($mediamtxProc.HasExited) {
    Write-Host ""
    Write-Host "ERROR: MediaMTX exited immediately." -ForegroundColor Red
    # Show the actual log so the user knows the real reason
    if (Test-Path $mediamtxLog) {
        Write-Host ""
        Write-Host "--- mediamtx output ---" -ForegroundColor DarkGray
        Get-Content $mediamtxLog | Select-Object -Last 20 | ForEach-Object { Write-Host "  $_" -ForegroundColor DarkGray }
        $errLog = "$mediamtxDir\mediamtx-err.log"
        if ((Test-Path $errLog) -and (Get-Item $errLog).Length -gt 0) {
            Get-Content $errLog | Select-Object -Last 10 | ForEach-Object { Write-Host "  $_" -ForegroundColor DarkGray }
        }
        Write-Host "--- end of log ---" -ForegroundColor DarkGray
    }
    Write-Host ""
    Write-Host "Possible causes:" -ForegroundColor Yellow
    Write-Host "  - Port 8554 is already in use (another MediaMTX still running?)" -ForegroundColor Yellow
    Write-Host "  - mediamtx.yml could not be read" -ForegroundColor Yellow
    Write-Host "  - Antivirus blocked mediamtx.exe" -ForegroundColor Yellow
    Write-Host ""
    Write-Host "Press Enter to close..."
    Read-Host | Out-Null
    exit 1
}
Write-Host "[MediaMTX] Running (PID $($mediamtxProc.Id))"

# ---------------------------------------------------------------------------
# Start FFmpeg for each camera
# ---------------------------------------------------------------------------

$ffmpegProcs = [System.Collections.Generic.List[hashtable]]::new()

foreach ($cam in $cameras) {
    $args = Build-FFmpegArgs -CameraName $cam.Name -StreamPath $cam.Stream
    $logOut = "$mediamtxDir\ffmpeg-cam$($cam.Index)-out.log"
    $logErr = "$mediamtxDir\ffmpeg-cam$($cam.Index)-err.log"
    Write-Host "[Camera $($cam.Index)] Starting: $($cam.Name)  ->  rtsp://localhost:8554/$($cam.Stream)"
    $proc = Start-Process `
        -FilePath $ffmpeg `
        -ArgumentList $args `
        -PassThru `
        -NoNewWindow `
        -RedirectStandardOutput $logOut `
        -RedirectStandardError  $logErr
    $ffmpegProcs.Add(@{ Name = "Camera $($cam.Index)"; Proc = $proc; LogOut = $logOut; LogErr = $logErr; Reported = $false })
    Start-Sleep -Milliseconds 800
}

Start-Sleep -Seconds 1

# ---------------------------------------------------------------------------
# Show connection info
# ---------------------------------------------------------------------------

$localIp = (
    Get-NetIPAddress -AddressFamily IPv4 |
    Where-Object {
        $_.InterfaceAlias -notlike "*Loopback*" -and
        $_.PrefixOrigin   -ne "WellKnown"       -and
        $_.IPAddress      -notlike "169.254.*"
    } |
    Sort-Object -Property InterfaceMetric |
    Select-Object -First 1
).IPAddress

Write-Host ""
Write-Host "========================================================="
Write-Host " Streams are live!  ($($cameras.Count) camera(s))"
Write-Host "========================================================="
Write-Host ""
foreach ($cam in $cameras) {
    Write-Host "  Camera $($cam.Index): rtsp://${localIp}:8554/$($cam.Stream)"
}
Write-Host ""
Write-Host "Add each URL as a monitor in ZoneMinder:"
Write-Host "  Source Type : FFmpeg"
Write-Host "  Source Path : rtsp://${localIp}:8554/<stream>"
Write-Host ""
Write-Host "Press Ctrl+C to stop all streams."
Write-Host "========================================================="
Write-Host ""

# ---------------------------------------------------------------------------
# Monitor loop - watch for unexpected exits and clean up on Ctrl+C
# ---------------------------------------------------------------------------

$procs = [System.Collections.Generic.List[hashtable]]::new()
$procs.Add(@{ Name = "MediaMTX"; Proc = $mediamtxProc; LogErr = $mediamtxLog; Reported = $false })
foreach ($fp in $ffmpegProcs) { $procs.Add($fp) }

try {
    while ($true) {
        Start-Sleep -Seconds 5
        foreach ($entry in $procs) {
            if ($entry.Proc.HasExited -and -not $entry.Reported) {
                $entry.Reported = $true
                Write-Warning "$($entry.Name) (PID $($entry.Proc.Id)) exited unexpectedly (code $($entry.Proc.ExitCode))."
                if ($entry.LogErr -and (Test-Path $entry.LogErr)) {
                    Write-Host "--- $($entry.Name) output (last 30 lines) ---" -ForegroundColor DarkGray
                    Get-Content $entry.LogErr | Select-Object -Last 30 | ForEach-Object { Write-Host "  $_" -ForegroundColor DarkGray }
                    Write-Host "--- end of log ---" -ForegroundColor DarkGray
                }
            }
        }
    }
}
finally {
    Write-Host ""
    Write-Host "Stopping all processes..."
    foreach ($entry in $procs) {
        if (-not $entry.Proc.HasExited) {
            Write-Host "  Stopping $($entry.Name) (PID $($entry.Proc.Id))..."
            Stop-Process -Id $entry.Proc.Id -Force -ErrorAction SilentlyContinue
        }
    }
    Write-Host "All stopped."
    Write-Host ""
    Write-Host "Press Enter to close..."
    Read-Host | Out-Null
}
